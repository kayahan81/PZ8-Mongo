---
# Практическое задание 8

## ЭФМО-02-25 

## Алиев Каяхан Командар оглы
---
# Информация о проекте
Работа с MongoDB: подключение, создание коллекции, CRUD-операции

## Цели занятия
-	Понять базовые принципы документной БД MongoDB (документ, коллекция, BSON, _id:ObjectID).
-	Научиться подключаться к MongoDB из Go с использованием официального драйвера.
-	Создать коллекцию, индексы и реализовать CRUD для одной сущности (например, notes).
-	Отработать фильтрацию, пагинацию, обновления (в т.ч. частичные), удаление и обработку ошибок.

## Файловая структура проекта:

<img width="1156" height="527" alt="image" src="https://github.com/user-attachments/assets/0a519722-eafe-4dce-9172-a6cb8d827fe2" />

## Ключевые компоненты

cmd/api/main.go — точка входа приложения: инициализация подключения к MongoDB, создание репозитория и обработчиков для работы с заметками, настройка HTTP-маршрутов /api/v1/notes с поддержкой CRUD-операций и запуск сервера на порту 8080.

internal/db/mongo.go — модуль подключения к базе данных: обёртка над драйвером MongoDB, обеспечивающая установку соединения с таймаутами, выполнение ping-проверки и возврат клиента с указанной базой данных.

internal/notes/model.go — модель данных: структура Note с полями ID (ObjectID), Title, Content, CreatedAt, UpdatedAt и тегами bson/json для сериализации между Go и MongoDB.

internal/notes/repo.go — слой доступа к данным: репозиторий с методами Create, ByID, List, Update, Delete для выполнения CRUD-операций, включая создание уникального индекса на поле title и поддержку фильтрации с пагинацией.

internal/notes/handler.go — HTTP-обработчики: реализация REST API с маршрутизацией через Chi Router, валидацией входных данных, обработкой контекстов с таймаутами и возвратом JSON-ответов с соответствующими кодами статусов.

go.mod - файл модуля Go: описание зависимостей, версия Go, имя модуля

# Примечания по конфигурации и требования

Для запуска требуется:

Go: версия 1.25.1

PostgreSQL: версия не ниже 14

Docker: версия не ниже 29

Mongodb: 7.0.28

<img width="841" height="232" alt="Установка Git и Go" src="https://github.com/user-attachments/assets/8e01d831-5a7f-4376-8348-9052b240aec9" />
<img width="860" height="654" alt="image" src="https://github.com/user-attachments/assets/2138e11d-ee33-4f00-9e6b-7cffa60aadd3" />
<img width="382" height="57" alt="image" src="https://github.com/user-attachments/assets/40003be8-0fe6-4ac6-9772-872c5cafca4e" />


# Команды запуска/сборки
Для запуска http нужно выполнить 4 шага:
## 1) Клонировать данный репозиторий в удобную для вас папку:
```Powershell
git clone https://github.com/kayahan81/PZ7-Redis
```
## 2) Перейти в папку http:
```Powershell
cd PZ8-Mongo
```
## 3) Загрузка зависимостей:
```Powershell
go mod tidy
```
## 4) Команда запуска
```Powershell
go run ./cmd/api
```

# Команда сборки
Для сборки бинарника и запуска .exe файла используются данные программы

```Powershell
go build -o server.exe .
server.exe
```
# Проверка работоспособности

## Базовый функционал

Создание записи

<img width="1457" height="330" alt="2 проверка сервера" src="https://github.com/user-attachments/assets/ea3bac3b-6208-41ae-8f8e-18740059fe2d" />


Удаление записи

<img width="1456" height="282" alt="delete" src="https://github.com/user-attachments/assets/3a1bcb05-a101-41e1-9fa3-301f7a6ab8eb" />

Просмотр по ID

<img width="1442" height="225" alt="id" src="https://github.com/user-attachments/assets/a415b44f-1e83-4f25-b61d-20286c5bab3b" />

Изменение записи

<img width="1442" height="280" alt="patch" src="https://github.com/user-attachments/assets/b2b2ba8b-0fad-431c-a465-709a2232a06b" />

Список

<img width="1452" height="215" alt="spisok" src="https://github.com/user-attachments/assets/dfb1cc67-a2a1-4d54-99cc-9c74a077aec7" />

#Ответы на вопросы

1.	Чем документная модель MongoDB принципиально отличается от реляционной? Когда она удобнее?
Принципиальные отличия:
 MongoDB использует документы в формате BSON (JSON-подобные объекты), а реляционные СУБД — таблицы со строгими схемами и связями
 В одной коллекции MongoDB могут храниться документы с разными полями, в то время как SQL требует заранее определённую структуру таблиц
 MongoDB часто хранит вложенные объекты внутри документов, тогда как SQL использует связи между таблицами (JOIN)
 MongoDB изначально проектировалась для горизонтального масштабирования (sharding), в то время как SQL СУБД в первую очередь масштабируются вертикально

Когда MongoDB удобнее:
 При динамической и изменяющейся структуре данных (например, заметки, профили пользователей, каталоги товаров с разными атрибутами)
 Для хранения вложенных объектов и массивов без необходимости нормализации
 В сценариях с высокой скоростью вставки и выборки документов
 При работе с JSON-данными из веб-приложений и REST API

2.	Что такое ObjectID и зачем нужен _id? Как корректно парсить/валидировать его в Go?
ObjectID — это специальный 12-байтный идентификатор, который MongoDB автоматически создаёт для каждого документа при вставке, если явно не указан _id.
Парсинг из строки: oid, err := primitive.ObjectIDFromHex(idHex)
Проверка валидности: функция ObjectIDFromHex возвращает ошибку при неверном формате

3.	Какие операции CRUD предоставляет драйвер MongoDB и какие операторы обновления вы знаете?
Операции CRUD в драйвере MongoDB:

Create: InsertOne() для вставки одного документа, InsertMany() для нескольких
Read: FindOne() для получения одного документа, Find() для получения курсора с несколькими документами
Update: UpdateOne() для обновления одного документа, UpdateMany() для нескольких, FindOneAndUpdate() для атомарного обновления с возвратом
Delete: DeleteOne() для удаления одного документа, DeleteMany() для удаления нескольких

Операторы обновления:
$set: Устанавливает значение поля (частичное обновление)
$inc: Увеличивает числовое значение поля
$push: Добавляет элемент в массив
$pull: Удаляет элемент из массива по условию
$unset: Удаляет поле из документа
$rename: Переименовывает поле
$currentDate: Устанавливает текущую дату/время
$mul: Умножает числовое значение поля

4.	Как устроены индексы в MongoDB? Как создать уникальный индекс и чем он грозит при вставке?
Индексы в MongoDB работают аналогично B-деревьям в SQL СУБД
Создание уникального индекса:
_, err := col.Indexes().CreateOne(ctx, mongo.IndexModel{
    Keys: bson.D{{Key: "title", Value: 1}},
    Options: options.Index().SetUnique(true),
})

5.	Почему важно использовать context.WithTimeout при вызовах к базе? Что произойдет при его срабатывании?
Важность использования context.WithTimeout:
Без таймаута сетевое соединение с базой данных может зависнуть на неопределённое время при сетевых проблемах или перегрузке БД
Таймауты позволяют освобождать соединения и ресурсы приложения вовремя
Помогает приложению продолжать работу даже при временной недоступности БД
Предотвращает долгое ожидание ответа от API
Что происходит при срабатывании таймаута: Операция к базе данных прерыается, возвращается ошибка context deadline exceeded (в проекте это приводит к возврату HTTP-статуса 500 (Internal Server Error) с соответствующим сообщением об ошибке), соединение с MongoDB автоматически закрывается или возвращается в пул, приложение может продолжить обработку других запросов без блокировки
